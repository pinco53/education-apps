<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <!-- スマホでのピンチズームを防止し、アプリのような操作感に -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Graph Guardian: Variable Edition</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: #050510;
            color: white;
            overflow: hidden; /* スクロール防止 */
            touch-action: manipulation; /* ダブルタップズーム防止 */
        }

        /* Custom Animations */
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 204, 0.2); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 204, 0.6); }
        }
        
        .bg-grid {
            background-image: radial-gradient(circle, #1a1a3d 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .calculator-enter {
            animation: slideUp 0.3s ease-out forwards;
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen w-full relative">

    <!-- Background Effect -->
    <div class="absolute inset-0 bg-[radial-gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-slate-900 via-black to-black -z-10"></div>

    <!-- Main Layout Container -->
    <div class="w-full h-full flex flex-col gap-2 p-2 md:p-4 max-w-6xl mx-auto h-screen supports-[height:100dvh]:h-[100dvh]">

        <!-- Header -->
        <div class="flex justify-between items-end px-1 shrink-0">
            <div>
                <h1 class="text-lg md:text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 to-purple-500 flex items-center gap-2">
                    <i data-lucide="crosshair" class="text-cyan-400 w-5 h-5 md:w-6 md:h-6"></i>
                    <span class="hidden md:inline">GRAPH GUARDIAN:</span>
                    <span id="mission-type" class="text-yellow-400 text-base md:text-lg">FIND a</span>
                </h1>
                <div class="text-[10px] md:text-xs text-slate-400">
                    SYS: <span id="mode-display">Linear</span> | LVL: <span id="level-display">1</span>
                </div>
            </div>
            <div class="text-right">
                <div class="text-xl md:text-2xl text-green-400 font-bold tracking-widest" id="score-display">0</div>
                <div class="text-[10px] md:text-xs text-slate-500">SCORE</div>
            </div>
        </div>

        <!-- AI Bar -->
        <div id="ai-bar" class="shrink-0 w-full flex items-start gap-2 md:gap-3 p-2 md:p-3 rounded-lg border border-cyan-500/30 bg-slate-900/80 backdrop-blur shadow-lg transition-colors">
            <div class="bg-cyan-900/50 p-1.5 md:p-2 rounded-full border border-cyan-500/50 shrink-0">
                <i data-lucide="message-square" class="text-cyan-400 w-4 h-4 md:w-5 md:h-5" id="ai-icon"></i>
            </div>
            <div class="flex-1 min-w-0">
                <div class="text-[10px] md:text-xs font-bold text-cyan-400 mb-0.5">NAVIGATOR AI</div>
                <p class="text-xs md:text-sm text-slate-200 leading-relaxed truncate md:whitespace-normal" id="ai-message">敵機捕捉。データを確認してください。</p>
            </div>
            <button id="btn-hint" class="bg-slate-700 hover:bg-slate-600 text-cyan-300 border border-slate-600 px-2 py-1 md:px-3 md:py-1 rounded shadow text-[10px] md:text-xs font-bold whitespace-nowrap active:scale-95 flex items-center gap-1 transition-all">
                <i data-lucide="help-circle" class="w-3 h-3 md:w-4 md:h-4"></i> <span class="hidden sm:inline">ヒント</span>
            </button>
        </div>

        <!-- Game Viewport (Canvas) -->
        <div class="flex-1 relative flex flex-col min-h-0 bg-slate-900/20 border border-slate-800 rounded-lg overflow-hidden">
            
            <!-- Canvas Container: Use Flex to center and scaling -->
            <div class="relative w-full h-full flex items-center justify-center bg-black/50 overflow-hidden" id="canvas-container">
                <!-- Canvas size logic: object-contain to keep aspect ratio within container -->
                <canvas id="gameCanvas" class="max-w-full max-h-full object-contain block"></canvas>
                
                <!-- Target Info Overlay -->
                <div id="target-info" class="absolute top-2 right-2 md:top-4 md:right-4 bg-slate-900/80 border border-red-500/50 p-2 md:p-3 rounded text-right shadow-lg pointer-events-none hidden z-10">
                    <div class="text-[8px] md:text-[10px] text-red-400 font-bold tracking-widest mb-1">TARGET</div>
                    <div class="text-sm md:text-xl font-mono text-white">
                        x: <span class="text-yellow-400" id="target-x">?</span>
                    </div>
                    <div class="text-sm md:text-xl font-mono text-white">
                        y: <span class="text-yellow-400" id="target-y">?</span>
                    </div>
                    <div class="text-[8px] md:text-[10px] text-slate-400 mt-1 border-t border-slate-700 pt-1" id="target-formula">
                        MISSING
                    </div>
                </div>

                <!-- Victory Overlay -->
                <div id="victory-overlay" class="absolute inset-0 flex items-center justify-center bg-black/80 z-20 hidden p-4">
                    <div class="text-center animate-bounce">
                        <h2 class="text-2xl md:text-4xl font-bold text-green-400 mb-2">COMPLETE</h2>
                        <p class="text-sm md:text-base text-slate-300 mb-4 md:mb-6" id="victory-message">Excellent Work.</p>
                        <button id="btn-next-level" class="bg-green-600 hover:bg-green-500 text-black font-bold px-6 py-2 md:px-8 md:py-3 rounded text-base md:text-lg transition-all hover:scale-105 shadow-lg shadow-green-500/20">NEXT MISSION</button>
                    </div>
                </div>

                <!-- Calculator Modal -->
                <div id="calculator-modal" class="absolute bottom-16 right-2 md:bottom-20 md:right-4 w-56 md:w-64 bg-slate-800 border-2 border-cyan-500/50 rounded-lg shadow-2xl p-3 md:p-4 z-50 calculator-enter hidden">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-cyan-400 font-bold flex items-center gap-2 text-sm md:text-base">
                            <i data-lucide="calculator" class="w-4 h-4"></i> 計算機
                        </h3>
                        <button id="btn-close-calc" class="text-slate-400 hover:text-white p-1"><i data-lucide="x" class="w-4 h-4"></i></button>
                    </div>
                    <div id="calc-display" class="bg-black p-2 md:p-3 rounded text-right text-lg md:text-2xl font-mono text-green-400 mb-2 md:mb-3 overflow-hidden border border-slate-600 h-10 md:h-12 flex items-center justify-end">0</div>
                    <div class="grid grid-cols-4 gap-1 md:gap-2" id="calc-buttons">
                        <!-- Buttons generated by JS -->
                    </div>
                </div>

                <!-- Calc Toggle Button -->
                <button id="btn-open-calc" class="absolute bottom-2 right-2 md:bottom-4 md:right-4 bg-slate-700 hover:bg-slate-600 text-cyan-400 border border-cyan-500/50 p-2 md:p-3 rounded-full shadow-lg transition-all active:scale-95 z-10">
                    <i data-lucide="calculator" class="w-5 h-5 md:w-6 md:h-6"></i>
                </button>

            </div>

            <!-- Controls Panel -->
            <div class="shrink-0 bg-slate-900 border-t border-slate-700 p-2 md:p-4 flex flex-wrap items-center justify-between gap-2 z-30 min-h-[80px]">
                
                <!-- Mode Switch (Left) -->
                <div class="flex gap-1 md:gap-2 order-1 md:order-1">
                    <button id="btn-mode-linear" class="px-2 py-1 md:px-4 md:py-2 rounded text-xs md:text-sm font-bold transition-all bg-cyan-600 text-white whitespace-nowrap">比例 (ax)</button>
                    <button id="btn-mode-inverse" class="px-2 py-1 md:px-4 md:py-2 rounded text-xs md:text-sm font-bold transition-all bg-slate-800 text-slate-400 whitespace-nowrap">反比例 (a/x)</button>
                </div>

                <!-- Input Area (Center/Full on mobile) -->
                <div class="flex-1 flex justify-center items-center order-3 md:order-2 w-full md:w-auto" id="input-area">
                   <!-- Dynamic Input Area populated by JS -->
                </div>

                <!-- Fire Button (Right) -->
                <div class="order-2 md:order-3">
                    <button id="btn-fire" class="bg-red-600 hover:bg-red-500 text-white px-4 py-2 md:px-8 md:py-3 rounded shadow-[0_0_20px_rgba(220,38,38,0.6)] flex items-center gap-2 transition-all active:scale-95">
                        <i data-lucide="rocket" class="w-4 h-4 md:w-5 md:h-5"></i>
                        <span class="font-bold tracking-wider text-sm md:text-base">FIRE</span>
                    </button>
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- Constants & Config ---
        const apiKey = ""; 
        
        const COLORS = {
            bg: '#050510',
            grid: '#1a1a3d',
            axis: '#4d4dff',
            laser: '#00ffcc',
            wave: '#ff00ff',
            enemy: '#ff3333',
            player: '#00ccff',
            text: '#e0e0ff'
        };

        // Canvas logical resolution (Internal drawing size)
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 450;
        const AXIS_OFFSET_X = 60;
        const AXIS_OFFSET_Y = 400;
        const SCALE = 20;

        // State
        let mode = 'LINEAR';
        let level = 1;
        let score = 0;
        let gameState = 'PLAYING';
        let userInput = '';
        let targetConstant = 0;
        let enemies = [];
        let targetEnemy = null;
        let particles = [];
        let questionType = 'FIND_A'; 
        
        let animationFrameId;
        let firingProgress = 0;
        let processingHit = false;

        function init() {
            const canvas = document.getElementById('gameCanvas');
            // Set internal resolution
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            
            // Init Calculator
            const calcBtnsContainer = document.getElementById('calc-buttons');
            const calcKeys = ['7','8','9','/','4','5','6','*','1','2','3','-','0','.','=','+'];
            const clearBtn = document.createElement('button');
            clearBtn.className = "col-span-4 bg-red-900/50 hover:bg-red-800 text-red-200 rounded p-1 md:p-2 text-xs md:text-sm font-bold border border-red-500/30";
            clearBtn.innerText = "CLEAR";
            clearBtn.onclick = () => calcPress('C');
            calcBtnsContainer.appendChild(clearBtn);

            calcKeys.forEach(k => {
                const btn = document.createElement('button');
                btn.className = `p-1.5 md:p-2 rounded font-bold shadow active:scale-95 transition-colors text-sm md:text-base ${['/','*','-','+','='].includes(k) ? 'bg-slate-600 hover:bg-slate-500 text-yellow-400' : 'bg-slate-700 hover:bg-slate-600 text-white'}`;
                btn.innerText = k === '*' ? '×' : k === '/' ? '÷' : k;
                btn.onclick = () => calcPress(k);
                calcBtnsContainer.appendChild(btn);
            });

            lucide.createIcons();
            startLevel(1, 'LINEAR');
            gameLoop();
        }

        function startLevel(lvl, newMode) {
            mode = newMode;
            level = lvl;
            gameState = 'PLAYING';
            particles = [];
            firingProgress = 0;
            processingHit = false;
            userInput = '';
            
            const rand = Math.random();
            if (rand < 0.5) questionType = 'FIND_A';
            else if (rand < 0.75) questionType = 'FIND_Y';
            else questionType = 'FIND_X';

            if (level === 1) questionType = 'FIND_A';

            updateUI();
            generateEnemies();
            
            setAiMessage(getInitialAiMessage());
        }

        function updateUI() {
            document.getElementById('level-display').innerText = level;
            document.getElementById('mode-display').innerText = mode === 'LINEAR' ? 'Linear' : 'Inverse';
            document.getElementById('victory-overlay').classList.add('hidden');
            document.getElementById('btn-mode-linear').className = mode === 'LINEAR' ? "px-2 py-1 md:px-4 md:py-2 rounded text-xs md:text-sm font-bold transition-all bg-cyan-600 text-white whitespace-nowrap" : "px-2 py-1 md:px-4 md:py-2 rounded text-xs md:text-sm font-bold transition-all bg-slate-800 text-slate-400 whitespace-nowrap";
            document.getElementById('btn-mode-inverse').className = mode === 'INVERSE' ? "px-2 py-1 md:px-4 md:py-2 rounded text-xs md:text-sm font-bold transition-all bg-purple-600 text-white whitespace-nowrap" : "px-2 py-1 md:px-4 md:py-2 rounded text-xs md:text-sm font-bold transition-all bg-slate-800 text-slate-400 whitespace-nowrap";
            
            const missionTypeEl = document.getElementById('mission-type');
            missionTypeEl.innerText = questionType.replace('_', ' ');

            const container = document.getElementById('input-area');
            container.innerHTML = '';

            const inputHTML = `
                <div class="relative group">
                    <input type="number" id="param-input" placeholder="?" class="w-20 md:w-24 bg-slate-700 text-white text-center font-bold text-xl md:text-2xl rounded focus:outline-none focus:ring-2 focus:ring-cyan-400 text-cyan-400" value="${userInput}">
                    <span class="absolute -top-4 left-0 w-full text-center text-[10px] text-slate-400 group-hover:text-white transition-colors">${questionType.split('_')[1]}</span>
                </div>
            `;

            const wrapper = document.createElement('div');
            wrapper.className = "font-mono text-sm md:text-xl font-bold text-white flex items-center gap-2 md:gap-3 bg-slate-800 px-3 py-1 md:px-6 md:py-2 rounded border border-slate-600 shadow-inner w-full md:w-auto justify-center";

            let content = '';
            if (questionType === 'FIND_A') {
                content = `<span>y =</span> ${inputHTML} <span>${mode === 'LINEAR' ? 'x' : '/ x'}</span>`;
            } else if (questionType === 'FIND_X') {
                const operator = mode === 'LINEAR' ? '' : '/ ';
                if(mode === 'LINEAR') {
                    content = `<span>y = <span class="text-purple-400">${targetConstant}</span></span> ${inputHTML}`;
                } else {
                    content = `<span>y = <span class="text-purple-400">${targetConstant}</span> / </span> ${inputHTML}`;
                }
            } else if (questionType === 'FIND_Y') {
                const xVal = targetEnemy ? targetEnemy.x : 'x';
                const rhs = mode === 'LINEAR' 
                    ? `<span class="text-purple-400">${targetConstant}</span> · <span class="text-yellow-400">${xVal}</span>`
                    : `<span class="text-purple-400">${targetConstant}</span> / <span class="text-yellow-400">${xVal}</span>`;
                
                content = `${inputHTML} <span>= ${rhs}</span>`;
            }

            wrapper.innerHTML = content;
            container.appendChild(wrapper);

            const inputEl = document.getElementById('param-input');
            if(inputEl) {
                inputEl.oninput = (e) => { userInput = e.target.value; };
                // Don't auto focus on mobile to prevent keyboard pop-up covering game
                if(window.innerWidth > 768) inputEl.focus();
            }
        }

        function generateEnemies() {
            enemies = [];
            let correctA;

            if (mode === 'LINEAR') {
                const r = Math.random();
                if (r < 0.4) correctA = Math.floor(Math.random() * 5) + 1; 
                else correctA = Math.round((Math.random() * 3 + 0.5) * 10) / 10;
                
                const effectiveMaxX = Math.min(35, 18/correctA);
                const enemyCount = questionType === 'FIND_A' ? 2 : 1; 
                
                for(let i=0; i<enemyCount; i++) {
                    let x = Math.floor(Math.random() * (effectiveMaxX - 2)) + 2;
                    const y = Math.round(x * correctA * 100) / 100;
                    enemies.push({ id: Date.now()+i, x, y, hit: false });
                }
            } else {
                const candidates = [12, 24, 36, 48, 60];
                correctA = candidates[Math.floor(Math.random() * candidates.length)];
                
                const divisors = [];
                for(let x=1; x<=30; x++) {
                    if (correctA % x === 0 && (correctA/x) <= 18) divisors.push(x);
                }
                const count = questionType === 'FIND_A' ? 2 : 1;
                const picks = divisors.sort(() => 0.5 - Math.random()).slice(0, count);
                picks.forEach((x, i) => {
                    const y = correctA / x;
                    enemies.push({ id: Date.now()+i, x, y, hit: false });
                });
            }

            targetConstant = correctA;
            enemies.sort((a, b) => a.x - b.x);
            
            if (enemies.length > 0) {
                targetEnemy = enemies[0];
                updateTargetDisplay();
                updateUI(); 
            }
        }

        function updateTargetDisplay() {
            const infoBox = document.getElementById('target-info');
            if (!targetEnemy) {
                infoBox.classList.add('hidden');
                return;
            }
            infoBox.classList.remove('hidden');

            let xText = targetEnemy.x;
            let yText = targetEnemy.y;
            let formulaText = '';

            if (questionType === 'FIND_X') xText = '<span class="text-red-500 text-lg md:text-2xl">?</span>';
            if (questionType === 'FIND_Y') yText = '<span class="text-red-500 text-lg md:text-2xl">?</span>';

            if (mode === 'LINEAR') {
                if (questionType === 'FIND_A') formulaText = 'FIND a (y÷x)';
                if (questionType === 'FIND_X') formulaText = 'FIND x (y÷a)';
                if (questionType === 'FIND_Y') formulaText = 'FIND y (a×x)';
            } else {
                if (questionType === 'FIND_A') formulaText = 'FIND a (x×y)';
                if (questionType === 'FIND_X') formulaText = 'FIND x (a÷y)';
                if (questionType === 'FIND_Y') formulaText = 'FIND y (a÷x)';
            }

            document.getElementById('target-x').innerHTML = xText;
            document.getElementById('target-y').innerHTML = yText;
            document.getElementById('target-formula').innerText = formulaText;
        }

        function getInitialAiMessage() {
            if (questionType === 'FIND_A') return "敵機捕捉。xとyから定数aを計算してください。";
            if (questionType === 'FIND_X') return "ステルス敵機接近。yからxを逆算し、位置を特定せよ！";
            if (questionType === 'FIND_Y') return "ステルス敵機接近。xからyを予測し、位置を特定せよ！";
            return "準備完了。";
        }

        function fireWeapon() {
            if (gameState !== 'PLAYING') return;
            if (userInput === '' || isNaN(parseFloat(userInput))) {
                setAiMessage("エラー：数値を入力してください！");
                return;
            }
            gameState = 'FIRING';
            firingProgress = 0;
            processingHit = false;
            setAiMessage("軌道データ入力確認…発射！！");
        }

        function handleHit() {
            processingHit = true;
            const userVal = parseFloat(userInput);
            const tolerance = 0.1;
            let isCorrect = false;

            let drawnA = targetConstant;
            if (questionType === 'FIND_A') {
                drawnA = userVal;
                isCorrect = Math.abs(userVal - targetConstant) < tolerance;
            } else if (questionType === 'FIND_X') {
                isCorrect = Math.abs(userVal - targetEnemy.x) < tolerance;
            } else if (questionType === 'FIND_Y') {
                isCorrect = Math.abs(userVal - targetEnemy.y) < tolerance;
            }

            let hitCount = 0;
            enemies.forEach(e => {
                let trajY = mode === 'LINEAR' ? drawnA * e.x : drawnA / e.x;
                if (Math.abs(trajY - e.y) < 0.5) {
                    if (questionType === 'FIND_A') {
                        e.hit = true;
                        hitCount++;
                        spawnExplosion(e.x, e.y);
                    } else if (isCorrect) {
                        e.hit = true;
                        hitCount++;
                        spawnExplosion(e.x, e.y);
                    }
                }
            });

            if ((questionType === 'FIND_A' && hitCount > 0 && isCorrect) || (questionType !== 'FIND_A' && isCorrect)) {
                score += 500;
                updateScore();
                setTimeout(() => {
                    gameState = 'VICTORY';
                    let ans = "";
                    if (questionType === 'FIND_A') ans = `a = ${targetConstant}`;
                    else if (questionType === 'FIND_X') ans = `x = ${targetEnemy.x}`;
                    else ans = `y = ${targetEnemy.y}`;
                    
                    document.getElementById('victory-message').innerText = `正解：${ans}`;
                    document.getElementById('victory-overlay').classList.remove('hidden');
                    setAiMessage(`計算通りです！完璧な予測でした。`);
                }, 1000);
            } else {
                setAiMessage("計算結果に誤差あり。ターゲットを捕捉できませんでした。");
                setTimeout(() => { gameState = 'PLAYING'; processingHit = false; }, 1500);
            }
        }

        function spawnExplosion(x, y) {
            for(let i=0; i<10; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random()-0.5)*0.5, vy: (Math.random()-0.5)*0.5,
                    life: 30, color: '#ffaa00'
                });
            }
        }

        function gameLoop() {
            const ctx = document.getElementById('gameCanvas').getContext('2d');
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            drawGrid(ctx);
            drawAxes(ctx);
            drawEnemies(ctx);
            drawPlayer(ctx);
            drawTrajectory(ctx);
            drawParticles(ctx);

            update();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy; p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }
            if (gameState === 'FIRING') {
                firingProgress += 2;
                if (firingProgress >= 100 && !processingHit) {
                    handleHit();
                }
            }
        }

        function drawGrid(ctx) {
            ctx.strokeStyle = COLORS.grid;
            ctx.lineWidth = 1;
            for(let x = 0; x < CANVAS_WIDTH; x += SCALE) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, CANVAS_HEIGHT); ctx.stroke();
            }
            for(let y = 0; y < CANVAS_HEIGHT; y += SCALE) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(CANVAS_WIDTH, y); ctx.stroke();
            }
        }

        function drawAxes(ctx) {
            ctx.strokeStyle = COLORS.axis;
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, AXIS_OFFSET_Y); ctx.lineTo(CANVAS_WIDTH, AXIS_OFFSET_Y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(AXIS_OFFSET_X, 0); ctx.lineTo(AXIS_OFFSET_X, CANVAS_HEIGHT); ctx.stroke();
            
            ctx.fillStyle = COLORS.text;
            ctx.font = '12px "JetBrains Mono", monospace';
            ctx.fillText("0", AXIS_OFFSET_X - 15, AXIS_OFFSET_Y + 15);
            
            for (let i = 5; i <= 35; i+=5) {
                ctx.fillText(i.toString(), AXIS_OFFSET_X + i*SCALE - 5, AXIS_OFFSET_Y + 20);
                if (i <= 20) {
                    const textWidth = ctx.measureText(i.toString()).width;
                    ctx.fillText(i.toString(), AXIS_OFFSET_X - textWidth - 10, AXIS_OFFSET_Y - i*SCALE + 5);
                }
            }
        }

        function drawEnemies(ctx) {
            enemies.forEach(enemy => {
                if ((questionType === 'FIND_X' || questionType === 'FIND_Y') && !enemy.hit) {
                    ctx.save();
                    ctx.strokeStyle = '#4ade80'; 
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    
                    if (questionType === 'FIND_Y') {
                        const px = AXIS_OFFSET_X + enemy.x * SCALE;
                        ctx.moveTo(px, 0); ctx.lineTo(px, CANVAS_HEIGHT);
                    } else {
                        const py = AXIS_OFFSET_Y - enemy.y * SCALE;
                        ctx.moveTo(0, py); ctx.lineTo(CANVAS_WIDTH, py);
                    }
                    ctx.stroke();
                    ctx.restore();
                    return; 
                }

                const px = AXIS_OFFSET_X + enemy.x * SCALE;
                const py = AXIS_OFFSET_Y - enemy.y * SCALE;
                
                ctx.fillStyle = COLORS.enemy;
                ctx.beginPath(); ctx.moveTo(px, py - 10); ctx.lineTo(px + 8, py + 5); ctx.lineTo(px - 8, py + 5); ctx.fill();
                
                let label = `(${enemy.x}, ${enemy.y})`;
                if (enemy === targetEnemy) {
                    if (questionType === 'FIND_X') label = `(?, ${enemy.y})`;
                    if (questionType === 'FIND_Y') label = `(${enemy.x}, ?)`;
                }
                
                ctx.fillStyle = '#ffaaaa';
                ctx.font = '10px monospace';
                ctx.fillText(label, px + 10, py);
            });
        }

        function drawPlayer(ctx) {
            ctx.fillStyle = COLORS.player;
            ctx.beginPath(); ctx.arc(AXIS_OFFSET_X, AXIS_OFFSET_Y, 15, 0, Math.PI, true); ctx.fill();
        }

        function drawTrajectory(ctx) {
            let drawA = 0;
            
            if (gameState === 'FIRING') {
                drawA = targetConstant; 
                if (questionType === 'FIND_A') {
                    drawA = parseFloat(userInput) || 0;
                }
            } else {
                if (questionType === 'FIND_A') {
                    drawA = parseFloat(userInput) || 0;
                } else {
                    drawA = 0; 
                }
            }

            if (drawA === 0) return;

            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.clip();

            if (gameState === 'FIRING') {
                const maxX = 40;
                const currentMaxX = (firingProgress / 100) * maxX;
                
                if (mode === 'LINEAR') {
                    const endX = AXIS_OFFSET_X + currentMaxX * SCALE;
                    const endY = AXIS_OFFSET_Y - (currentMaxX * drawA) * SCALE;
                    ctx.strokeStyle = COLORS.laser;
                    ctx.lineWidth = 4;
                    ctx.shadowColor = COLORS.laser;
                    ctx.shadowBlur = 15;
                    ctx.beginPath(); ctx.moveTo(AXIS_OFFSET_X, AXIS_OFFSET_Y); ctx.lineTo(endX, endY); ctx.stroke();
                } else {
                    ctx.strokeStyle = COLORS.wave;
                    ctx.lineWidth = 4;
                    ctx.shadowColor = COLORS.wave;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    let first = true;
                    for (let x = 0.1; x <= currentMaxX; x += 0.1) {
                        const y = drawA / x;
                        const px = AXIS_OFFSET_X + x * SCALE;
                        const py = AXIS_OFFSET_Y - y * SCALE;
                        if (py < -50 || py > CANVAS_HEIGHT + 50) continue;
                        if (first) { ctx.moveTo(px, py); first = false; }
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
            } else {
                ctx.strokeStyle = mode === 'LINEAR' ? 'rgba(0, 255, 204, 0.3)' : 'rgba(255, 0, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                if (mode === 'LINEAR') {
                    ctx.moveTo(AXIS_OFFSET_X, AXIS_OFFSET_Y);
                    const endX = 40;
                    const endY = endX * drawA;
                    ctx.lineTo(AXIS_OFFSET_X + endX * SCALE, AXIS_OFFSET_Y - endY * SCALE);
                } else {
                    let first = true;
                    for (let x = 0.1; x <= 40; x += 0.2) {
                        const y = drawA / x;
                        const px = AXIS_OFFSET_X + x * SCALE;
                        const py = AXIS_OFFSET_Y - y * SCALE;
                        if (py < -50) continue;
                        if (first) { ctx.moveTo(px, py); first = false; }
                        else ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }
            ctx.restore();
        }

        function drawParticles(ctx) {
            particles.forEach(p => {
                const px = AXIS_OFFSET_X + p.x * SCALE;
                const py = AXIS_OFFSET_Y - p.y * SCALE;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.fillRect(px, py, 3, 3);
                ctx.globalAlpha = 1.0;
            });
        }

        function updateScore() {
            document.getElementById('score-display').innerText = score;
        }
        
        function setAiMessage(msg) {
            const bar = document.getElementById('ai-bar');
            const icon = document.getElementById('ai-icon');
            document.getElementById('ai-message').innerText = msg;
            
            if (msg.includes("計算中") || msg.includes("起動中")) {
                bar.classList.add('border-yellow-400/50', 'bg-yellow-900/20');
                icon.classList.replace('text-cyan-400', 'text-yellow-400');
                icon.setAttribute('data-lucide', 'refresh-cw');
            } else {
                bar.classList.remove('border-yellow-400/50', 'bg-yellow-900/20');
                bar.classList.add('border-cyan-500/30', 'bg-slate-900/80');
                icon.classList.replace('text-yellow-400', 'text-cyan-400');
                icon.setAttribute('data-lucide', 'message-square');
            }
            lucide.createIcons();
        }

        // Calculator Logic
        let calcDisplay = '0';
        let calcResetNext = false;
        
        function calcPress(val) {
            if (val === 'C') {
                calcDisplay = '0';
                calcResetNext = false;
            } else if (val === '=') {
                try {
                    const result = Function('"use strict";return (' + calcDisplay + ')')();
                    calcDisplay = String(Math.round(result * 10000) / 10000);
                    calcResetNext = true;
                } catch (e) {
                    calcDisplay = 'Error';
                    calcResetNext = true;
                }
            } else {
                if (calcDisplay === '0' || calcDisplay === 'Error' || calcResetNext) {
                    calcDisplay = val;
                    calcResetNext = false;
                } else {
                    calcDisplay += val;
                }
            }
            document.getElementById('calc-display').innerText = calcDisplay;
        }

        async function callGemini(prompt) {
            setAiMessage("計算サポートを起動中...");
            if (!apiKey) {
                let hint = "";
                if(mode === 'LINEAR') {
                    if(questionType === 'FIND_A') hint = "y ÷ x を計算しよう";
                    if(questionType === 'FIND_X') hint = "y ÷ a を計算しよう";
                    if(questionType === 'FIND_Y') hint = "a × x を計算しよう";
                } else {
                    if(questionType === 'FIND_A') hint = "x × y を計算しよう";
                    if(questionType === 'FIND_X') hint = "a ÷ y を計算しよう";
                    if(questionType === 'FIND_Y') hint = "a ÷ x を計算しよう";
                }
                setTimeout(() => { setAiMessage("ヒント: " + hint); }, 1000);
                return;
            }
            try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }),
                    }
                );
                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "通信エラー";
                setAiMessage(text);
            } catch (error) {
                setAiMessage("通信エラーが発生しました。");
            }
        }

        // Event Listeners
        document.getElementById('btn-mode-linear').onclick = () => startLevel(1, 'LINEAR');
        document.getElementById('btn-mode-inverse').onclick = () => startLevel(1, 'INVERSE');
        document.getElementById('btn-fire').onclick = fireWeapon;
        document.getElementById('btn-next-level').onclick = () => startLevel(level + 1, mode);
        document.getElementById('btn-open-calc').onclick = () => {
            document.getElementById('calculator-modal').classList.remove('hidden');
            document.getElementById('btn-open-calc').classList.add('hidden');
        };
        document.getElementById('btn-close-calc').onclick = () => {
            document.getElementById('calculator-modal').classList.add('hidden');
            document.getElementById('btn-open-calc').classList.remove('hidden');
        };
        document.getElementById('btn-hint').onclick = () => {
            if (!targetEnemy) return;
            const prompt = `数学の先生としてヒントを。問題タイプ:${questionType}, モード:${mode}`;
            callGemini(prompt);
        };

        window.onload = init;
    </script>
</body>
</html>
